[
{
	"uri": "https://camel-k-integration-workshop.github.io/camel-k-workshop.github.io/1-intro/",
	"title": "Intro",
	"tags": [],
	"description": "",
	"content": "Prerequisites Before we start going through the workshop, make sure that you have VSCode or VSCodium installed on your machine. For simplicity, we will reference the IDE as VSCode going forward.\n If you are familiar with Git, you can clone following GitHub Repository and open it with VSCode: https://github.com/nexus-Six/camelk-integration-workshop.git\n We need to install the VSCode extensions \u0026ndash; Extension Pack for Apache Camel by Red Hat for later use.  Click image to enlarge   Telegram Account, Bot and Chat ID  Note: if you haven\u0026rsquo;t used telegram before, you can simply download the Telegram mobile app and create a new account there.\nAlternatively, you can follow this link to get the desktop version.\n Create a telegram bot ☐ Search for username @BotFather ☐ Start the chat (/start) ☐ Send /newbot to @BotFather ☐ Follow the instruction of @BotFather and create a name and username for the bot. ☐ Once the bot is created, we will get a token to access the HTTP API, keep the token secure and store it safely. ☐ You should search for your newly-created bot and click /start to initiate the conversation with the bot.\nGet our Chat ID ☐ Search for username @RawDataBot with name Telegram Bot Raw ☐ Start the chat (/start) ☐ You will receive a message from the @RawDataBot, store the \u0026quot;id\u0026quot; in the \u0026quot;chat\u0026quot; section somewhere safe.\nOnce we get the telegram bot token and the chat ID, remember to save them somewhere safe and easily accessible. We will need them in the following examples.\n "
},
{
	"uri": "https://camel-k-integration-workshop.github.io/camel-k-workshop.github.io/2-prepare-cluster/",
	"title": "Prepare your cluster",
	"tags": [],
	"description": "",
	"content": "Cluster Preparation Before you start you have to install a number of operators you\u0026rsquo;ll use during the workshop. These two are Red Hat Integration - Camel K for providing Camel services in your cluster and Red Hat OpenShift Serverless to make our application truly serverless and scalable. But fear not, both are managed by Kubernetes operators on OpenShift.\nInstall and prepare Camel K Operator  In the Web Console, go to Operators \u0026gt; OperatorHub and search for Red Hat Integration - Camel K (You may need to disable search filters) Install the Red Hat Integration - Camel K Operator with default settings Go to Installed Operators \u0026gt; Red Hat Integration - Camel K Operator and click on the Create Instance tile in the camel-k-workshop project !!!!check if this step is needed!!!!!. Done!  Install and prepare OpenShift Serverless operator  In the Web Console, go to Operators \u0026gt; OperatorHub and search for Red Hat OpenShift Serverless (You may need to disable search filters) Install the Red Hat OpenShift Serverless Operator with default settings Go to Installed Operators \u0026gt; Red Hat Integration - Camel K Operator and click on the Create Instance tile in the camel-k-workshop project !!!!check if this step is needed!!!!!. Done!  Login to OpenShift from your local machine  If you don\u0026rsquo;t already have the oc client installed, you can download the matching version for your operating system here Log into your OpenShift Webconsole with you cluster admin credentials In the top right corner, click on your username and then Copy login command to copy your login token On you local machine either:  open a terminal and log in with the oc command you copied OR use the integrated terminal in VSCode to log in with the oc command you copied    Your cluster is now prepared for the next step, proceed to the Task 1 - Hello World.\n"
},
{
	"uri": "https://camel-k-integration-workshop.github.io/camel-k-workshop.github.io/3-hello-world/",
	"title": "Task 1 - Hello World",
	"tags": [],
	"description": "",
	"content": "This example demonstrates a simple Camel K integration that periodically prints a \u0026ldquo;Hello World from Camel K\u0026rdquo;. Let\u0026rsquo;s recap the simple architecture of this example:\n Click image to enlarge   Let\u0026rsquo;s begin! ☐ Make sure you have the terminal in VSCode opened and you are logged to OpenShift ☐ oc new-project helloworld - create a new project with the name \u0026lsquo;helloworld\u0026rsquo; ☐ oc get csv - you should see the Camel K operator running ☐ Create a helloworld.groovy file\n We will elaborate on the integration file during the workshop\n ☐ kamel run helloworld.groovy - run the integration using kamel\n It might take up to 3 minutes for the integration to run.\n ☐ oc get integrations - check if the integration is running ☐ kamel logs helloworld - get the logs of the running integration\n You will see the hello world message printing out in the terminal every 3 seconds If you run kamel run helloworld.groovy --logs in the beginning, you will see the logs showing in the terminal as well\n ☐ kamel run helloworld.groovy --dev - alternatively, run the integration in the dev mode ☐ change the from('timer:tick?period=3000') to from('timer:tick?period=5000') in the helloworld.groovy file\n The running integration will reload, a few seconds later you will see the hello world message printing out in the terminal every 5 seconds\n ☐ oc delete project helloworld - clean up the namespace\n"
},
{
	"uri": "https://camel-k-integration-workshop.github.io/camel-k-workshop.github.io/4-chuck-norris/",
	"title": "Task 2 - Kamelet example",
	"tags": [],
	"description": "",
	"content": "This example demonstrates how to create a simple Chuck Norris Kamelet source and how to integrate it with telegram. Our goal is to receive some funny jokes on our Telegram channel.\n If you still don\u0026rsquo;t have your Telegram account, bot or chat ID, please refer to the first chapter \u0026ldquo;Intro\u0026rdquo; for the instructions on how to get them.\n Let\u0026rsquo;s get started ☐ oc new-project kamelet-example - create a new project for the second example ☐ Create a yaml file called chuck-norris-source.kamelet.yaml\n !!!!Add more information about creation of camelets here.!!!!!\n As Kamelets look like any other Camel component, experienced developers will enjoy using them as much, and will quickly browse through all the already available predefined Catalog Kamelets. It is possible to create your own kamelets You can define your own library of reusable kamelets for your organisation. And desirebly, contribute them to the Camel community. Kamelets have two kinds of connectors, sources and sinks. Sources produce the data and sinks consume the data and optionally produce a response.\nCamel provides more than 300 components out of the box, therefore we can create a Kamelet in a simple way, making use of one of the components already available. Most of the Kamelets available in the official catalog, are simple ones having only a remapping of the Kamelet properties into Camel endpoint parameters.\n☐ oc apply -f chuck-norris-source.kamelet.yaml - use the kamel to create the chuck norris source kamelet\n You can use kamel init xxxx-source.kamelet.yaml / xxxx-sink.kamelet.yaml to instantiate a kamelet template for creating your own custom kamelet.\n ☐ oc get kamelets - check if the chuck norris source is ready ☐ create a chuck-norris-example.groovy ☐ kamel run chuck-norris-example.groovy --dev- run the integration using chuck norris kamelet in the \u0026ldquo;dev mode\u0026rdquo;\n You should see the jokes appearing in the terminal. All the supported languages for Camel K integration\n ☐ Change the .to('log:info') to .to(\u0026quot;telegram:bots?authorizationToken=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\u0026amp;chatID=XXXXXXXXXXXXX\u0026quot;) - run the integration with telegram, provide the bot Token and chat ID\n You should be receiving jokes from your Telegram bot now.\n ☐ oc delete project chuck-norris - clean up the project\n"
},
{
	"uri": "https://camel-k-integration-workshop.github.io/camel-k-workshop.github.io/5-serverless/",
	"title": "Task 3 - Serverless integration with Camel K",
	"tags": [],
	"description": "",
	"content": "In this example, we will create a simple telegram source Kamelet and use KameletBinding to bind the source to a Knative channel. Then we will create a Printer that prints out the messages sent to the telegram source.\nIn the previous example, we\u0026rsquo;ve talked about the concept of Kamelet. So what is a KameletBinding? A KameletBinding lets you tell a Kamelet source to send events to a destination that can be represented by a Knative channel or a Kafka topic, the same mechanism lets a Kamelet sink consume events from a destination. Therefore, you can use KameletBindings to define the high-level flows of an event-driven architecture, as you can see in the following picture, we will create all the components in the architecture together in this example.\n Click image to enlarge   First let\u0026rsquo;s create a new project on the OpenShift cluster:\n☐ oc new-project userX-message-printer - this command will create a new project for the message printer example, alternatively you can use OpenShift web console to create a new project.\n☐ oc get csv - to make sure the Camel K and OpenShift Serverless operators are running in the namespace\nOpenShift Serverless provides Kubernetes native building blocks that enable us to create and deploy serverless, event-driven applications on OpenShift. It is based on the Knative project. But what is Knative? What is Serverless?\nServerless is a cloud-native development model that allows developers to build and run applications without having to manage servers. Serverless offerings are usually metered on-demand through an event-driven execution model. Serverless applications are deployed in containers that automatically launch on demand when needed.\nKnative is an open source project that helps us deploy, run, manage serverless applications on Kubernetes or OpenShift. For serverless applications, Your code only runs when it needs to, with Knative starting and stopping instances automatically. How does it achieve this? Now we need to talk about the two important components of Knative: Serving and Eventing.\n Serving - Enables rapid deployment of containers and automatic scaling of pods through a request-driven model for serving workloads based on demand. Eventing - An infrastructure for consuming and producing events to stimulate serverless apps. Apps can be triggered by a variety of sources, e.g. AMQ Streams, events from your own apps.  ☐ Create both instances of Knative Serving and Eventing via OpenShift Serverless operator on the web console\n☐ oc apply -f telegram-simple-source.kamelet.yaml - create a telegram-simple-source.kamelet.yaml\nspec: definition: title: \u0026#34;Telegram Source\u0026#34; description: |- Receive all messages that people send to your Telegram bot. To create a bot, contact the @botfather account using the Telegram app. The source attaches the following headers to the messages: - `chat-id` / `ce-chat-id`: the ID of the chat where the message comes from required: - authorizationToken type: object properties: authorizationToken: title: Token description: The token to access your bot on Telegram. You you can obtain it from the Telegram @botfather. type: string format: password x-descriptors: - urn:alm:descriptor:com.tectonic.ui:password This section is a simple definition of the Telegram source, it will retrieve all the messages sent to the Telegram bot. Importantly, we want to configure the source correctly by specifying the required property which is authorizationToken, which allows us to access the bot.\nflow: from: uri: telegram:bots parameters: authorizationToken: \u0026#34;{{authorizationToken}}\u0026#34; steps: - convert-body-to: type: \u0026#34;java.lang.String\u0026#34; charset: \u0026#34;UTF8\u0026#34; - filter: simple: \u0026#34;${body} != null\u0026#34; - log: \u0026#34;${body}\u0026#34; - to: \u0026#34;kamelet:sink\u0026#34; The flow section defines the integration flow. In this case, it goes from the Telegram bot, and will go through the steps defined in the steps, finally ends up in the kamelet:sink.\n☐ oc get kamelets - check if the source kamelet is ready ☐ oc apply -f telegram-channel.yaml - create a Knative InMemory Channel on the cluster ☐ oc apply -f telegram-source-binding.yaml - create a telegram-source-binding.yaml that binds the Knative channel to the telegram source\n Please replace the \u0026lt;your-bot-token\u0026gt; to your actual bot token!\n source: ref: kind: Kamelet apiVersion: camel.apache.org/v1alpha1 name: telegram-simple-source properties: authorizationToken: \u0026#34;\u0026lt;your-bot-token\u0026gt;\u0026#34; This source section shows us how to refer the Kamelet source using the property authorizationToken, this makes sure that messages produced by the Telegram source are forwarded to the Knative InMemoryChannel named \u0026ldquo;telegram\u0026rdquo;, which is referred in the sink section (see the following code block).\nsink: ref: apiVersion: messaging.knative.dev/v1 kind: InMemoryChannel name: telegram ☐ oc get integrations - check the status of the KameletBinding\n☐ kamel run printer.groovy - create the integration that prints out the messages sent to the telegram bot\nfrom(\u0026#39;knative:channel/telegram\u0026#39;) .convertBodyTo(String.class) .to(\u0026#39;log:info\u0026#39;) Here we create the simple event consumer that takes the messages from the Knative Channel and then print them out in the log.\n☐ Send some messages to your telegram bot ☐ kamel logs printer - check the logs of the printer\n You can also go to the OpenShift web console and check the logs of Printer pod. knative Serving enables autoscaling of the applications and it is event driven, so if we don’t send any messages from now on, you should see the pod scale down to 0 automatically, maybe we need to wait for a bit.\n ☐ Stop sending messages to the telegram bot\n Printer pod autoscales to zero If you want to trigger the printer running again, you can simply send the message to the bot again, and after a few second, you should see the printer pod will start scaling up again.\n ☐ oc delete project userX-message-printer - clean up the namespace\nCongrats!! We’ve achieved the final example!\n"
},
{
	"uri": "https://camel-k-integration-workshop.github.io/camel-k-workshop.github.io/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Camel K Workshop What is it about This workshop aims to help gain your first hands-on experience with Camel K and the important concepts such as Kamelets, KameletBindings and Knative.\nArchitecture overview The workshop consists of 3 separate exercises.  In the first one, the goal is to create the simplest route file to create a \u0026ldquo;Hello World\u0026rdquo; message and log it to the terminal in the set time interval.   Click image to enlarge   The second exercise\u0026rsquo;s goal is to create an integration using a Kamelet - new concept introduced in Camel K that allow users to connect to external systems via a simplified interface, hiding all the low level details about how those connections are implemented. To showcase the use of it, we will connect to the database of Chuck Norris jokes using just one command. Then we will send the joke to the terminal first, and then we will also send it as a Telegram message. In order to do that, Telegram account and Telegram bot will be required.   Click image to enlarge   The third and last exercise will teach you about how to utilize Knative to create serverless applications that scale depending on the workload. This time we\u0026rsquo;ll be sending messages to the Telegram bot and watch it\u0026rsquo;s behavior, i.e. how it scales up and down depending on the frequency of receiving new messages.   Click image to enlarge   Collaboration This workshop was created by Rui Zhang, Tala Ismail, Fabian Popp and Adrian Luberda.\nFeel free to create a pull request or an issue in GitHub.\n"
},
{
	"uri": "https://camel-k-integration-workshop.github.io/camel-k-workshop.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://camel-k-integration-workshop.github.io/camel-k-workshop.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]